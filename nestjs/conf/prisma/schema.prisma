// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"

}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       Int    @id @default(autoincrement())
  username String @unique

  connectedUser ConnectedUser?

  sentFriendships     Friendship[] @relation("Sender")
  receivedFriendships Friendship[] @relation("Receiver")

  sendDirectMessages     DirectMessage[] @relation("Sender")
  receivedDirectMessages DirectMessage[] @relation("Receiver")

  ChannelMember ChannelMember[]

  inviteeforChannels ChannelInvitation[] @relation("Invitee")
  inviterforChannels ChannelInvitation[] @relation("Inviter")

  leftPlayerMatches  Match[] @relation("LeftPlayer")
  rightPlayerMatches Match[] @relation("RightPlayer")
}

model ConnectedUser {
  id       Int    @id @default(autoincrement())
  socketId String @unique
  userId   Int    @unique

  user User @relation(fields: [userId], references: [id])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Friendship {
  id          Int              @id @default(autoincrement())
  senderId    Int
  receiverId  Int
  status      FriendshipStatus @default(PENDING)
  requestedAt DateTime         @default(now())

  sender   User @relation("Sender", fields: [senderId], references: [id])
  receiver User @relation("Receiver", fields: [receiverId], references: [id])

  @@unique([senderId, receiverId])
}

model DirectMessage {
  id         Int     @id @default(autoincrement())
  messageId  Int     @unique
  senderId   Int
  receiverId Int
  isRead     Boolean @default(false)

  message  Message @relation(fields: [messageId], references: [id])
  sender   User    @relation("Sender", fields: [senderId], references: [id])
  receiver User    @relation("Receiver", fields: [receiverId], references: [id])
}

model ChannelMessage {
  id        Int @id @default(autoincrement())
  messageId Int @unique
  senderId  Int

  message Message       @relation(fields: [messageId], references: [id])
  sender  ChannelMember @relation(fields: [senderId], references: [id], onDelete: Cascade)

  channelMessageReadStatus ChannelMessageReadStatus[]

  @@unique([messageId, senderId])
}

model ChannelMessageReadStatus {
  id        Int     @id @default(autoincrement())
  messageId Int
  readerId  Int
  isRead    Boolean

  message ChannelMessage @relation(fields: [messageId], references: [messageId], onDelete: Cascade)
  reader  ChannelMember  @relation(fields: [readerId], references: [id], onDelete: Cascade)
}

model Message {
  id        Int      @id @default(autoincrement())
  message   String
  createdAt DateTime @default(now())

  directMessage  DirectMessage?
  channelMessage ChannelMessage?
}

enum ChannelInvitationStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model ChannelInvitation{
	id 			Int @id @default(autoincrement())
	channelId 	Int
	inviteeId 	Int
	inviterId 	Int
	createdAt 	DateTime @default(now())
	status 		ChannelInvitationStatus @default(PENDING)

	channel 	Channel @relation(fields: [channelId], references: [id])
	invitee 	User	@relation("Invitee", fields: [inviteeId], references: [id])
	inviter 	User  	@relation("Inviter", fields: [inviterId], references: [id])



	@@unique([channelId, inviteeId])
}

enum ChannelVisibility {
  PUBLIC
  PRIVATE
}

model Channel {
  id           Int               @id @default(autoincrement())
  name         String            @unique
  visibility   ChannelVisibility @default(PUBLIC)
  protected    Boolean           @default(false)
  passwordHash String?

  members 		ChannelMember[]
  invitations 	ChannelInvitation[]
}

enum ChannelMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum ChannelMemberStatus {
  NORMAL
  MUTED
  BANNED
}

model ChannelMember {
  id          Int                 @id @default(autoincrement())
  userId      Int				 
  channelId   Int
  role        ChannelMemberRole
  roleSince   DateTime            @default(now())
  status      ChannelMemberStatus @default(NORMAL)
  statusSince DateTime            @default(now())
  banned      Boolean             @default(false)
  unmuteAt    DateTime?
  user        User                @relation(fields: [userId], references: [id])
  channel     Channel             @relation(fields: [channelId], references: [id])

  sendMessages ChannelMessage[]
  readStatus   ChannelMessageReadStatus[]

  @@unique([userId, channelId])
}

enum MatchType {
  LADDER
  CUSTOM
}

enum MatchState {
  CREATED
  INVITED
  ACCEPTED
  STARTED
  DISCONNECTLEFT
  DISCONNECTRIGHT
  WINNERLEFT
  WINNERRIGHT
}

model Match {
  id               Int        @id @default(autoincrement())
  leftUserId       Int
  rightUserId      Int?
  type             MatchType
  state            MatchState @default(CREATED)
  goalsLeftPlayer  Int        @default(0)
  goalsRightPlayer Int        @default(0)
  createdAt        DateTime   @default(now())
  startedAt        DateTime?
  finishedAt       DateTime?

  leftUser  User  @relation("LeftPlayer", fields: [leftUserId], references: [id])
  rightUser User? @relation("RightPlayer", fields: [rightUserId], references: [id])
}

