// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

generator prismaClassGenerator {
  provider = "prisma-class-generator"
  dryRun   = false
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          Int     @id @default(autoincrement())
  username    String  @unique
  avatarId    String?
  ladderLevel Int     @default(1000)
  enabled2FA  Boolean @default(false)
  secret2FA   String?

  connectedUser ConnectedUser?

  blockedUsers BlockedUser[] @relation("Blocked")
  blockedBy    BlockedUser[] @relation("BlockedBy")

  sentFriendships     Friendship[] @relation("Sender")
  receivedFriendships Friendship[] @relation("Receiver")

  sendDirectMessages     DirectMessage[] @relation("Sender")
  receivedDirectMessages DirectMessage[] @relation("Receiver")

  ChannelMember ChannelMember[]

  leftPlayerMatches  Match[] @relation("LeftPlayer")
  rightPlayerMatches Match[] @relation("RightPlayer")

  queue    Matchmaking? @relation("WaitingLadderGame")
  opponent Matchmaking? @relation("OpponentLadderGame")
}

model ConnectedUser {
  id       Int    @id @default(autoincrement())
  socketId String @unique
  userId   Int    @unique

  user User @relation(fields: [userId], references: [id])
}

enum FriendshipStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model Friendship {
  id          Int              @id @default(autoincrement())
  senderId    Int
  receiverId  Int
  status      FriendshipStatus @default(PENDING)
  requestedAt DateTime         @default(now())

  sender   User @relation("Sender", fields: [senderId], references: [id])
  receiver User @relation("Receiver", fields: [receiverId], references: [id])

  @@unique([senderId, receiverId])
}

model DirectMessage {
  id         Int     @id @default(autoincrement())
  messageId  Int     @unique
  senderId   Int
  receiverId Int
  isRead     Boolean @default(false)

  message  Message @relation(fields: [messageId], references: [id])
  sender   User    @relation("Sender", fields: [senderId], references: [id])
  receiver User    @relation("Receiver", fields: [receiverId], references: [id])
}

model ChannelMessage {
  id        Int @id @default(autoincrement())
  messageId Int @unique
  senderId  Int

  message Message       @relation(fields: [messageId], references: [id])
  sender  ChannelMember @relation(fields: [senderId], references: [id])

  channelMessageReadStatus ChannelMessageReadStatus[]

  @@unique([messageId, senderId])
}

model ChannelMessageReadStatus {
  id        Int     @id @default(autoincrement())
  messageId Int
  readerId  Int
  isRead    Boolean

  message ChannelMessage @relation(fields: [messageId], references: [id])
  reader  ChannelMember  @relation(fields: [readerId], references: [id])
}

model Message {
  id        Int      @id @default(autoincrement())
  message   String
  createdAt DateTime @default(now())

  directMessage  DirectMessage?
  channelMessage ChannelMessage?
}

enum ChannelVisibility {
  PUBLIC
  PRIVATE
}

model Channel {
  id           Int               @id @default(autoincrement())
  name         String            @unique
  visibility   ChannelVisibility @default(PUBLIC)
  protected    Boolean           @default(false)
  passwordHash String?

  members ChannelMember[]
}

enum ChannelMemberRole {
  OWNER
  ADMIN
  MEMBER
}

enum ChannelMemberStatus {
  NORMAL
  MUTED
  BANNED
}

model ChannelMember {
  id          Int                 @id @default(autoincrement())
  userId      Int
  channelId   Int
  role        ChannelMemberRole
  roleSince   DateTime            @default(now())
  status      ChannelMemberStatus @default(NORMAL)
  statusSince DateTime            @default(now())
  banned      Boolean             @default(false)
  unmuteAt    DateTime?
  user        User                @relation(fields: [userId], references: [id])
  channel     Channel             @relation(fields: [channelId], references: [id])

  sendMessages ChannelMessage[]
  readStatus   ChannelMessageReadStatus[]

  @@unique([userId, channelId])
}

enum MatchType {
  LADDER
  CUSTOM
}

enum MatchState {
  CREATED
  INVITED
  ACCEPTED
  STARTED
  DISCONNECTLEFT
  DISCONNECTRIGHT
  WINNERLEFT
  WINNERRIGHT
}

model Match {
  id               Int        @id @default(autoincrement())
  leftUserId       Int
  rightUserId      Int?
  type             MatchType
  state            MatchState @default(CREATED)
  goalsLeftPlayer  Int        @default(0)
  goalsRightPlayer Int        @default(0)
  createdAt        DateTime   @default(now())
  startedAt        DateTime?
  finishedAt       DateTime?

  leftUser  User  @relation("LeftPlayer", fields: [leftUserId], references: [id])
  rightUser User? @relation("RightPlayer", fields: [rightUserId], references: [id])
}

model BlockedUser {
  id           Int      @id @default(autoincrement())
  userId       Int
  targetUserId Int
  blockedAt    DateTime @default(now())

  user       User @relation("BlockedBy", fields: [userId], references: [id])
  targetUser User @relation("Blocked", fields: [targetUserId], references: [id])
}

model Matchmaking {
  id             Int @id @default(autoincrement())
  userId         Int @unique
  opponentUserId Int? @unique

  user     User @relation("WaitingLadderGame", fields: [userId], references: [id])
  opponent User? @relation("OpponentLadderGame", fields: [opponentUserId], references: [id])
}

// model Channel {
//   id         Int               @id @default(autoincrement())
//   name       String            @unique
//   password   String?           @default("")
//   ownerId    Int
//   owner      User              @relation("OwnedChannels", fields: [ownerId], references: [id])
//   members    ChannelMember[]
//   visibility ChannelVisibility @default(PUBLIC)
// }

// model ChannelMember {
//   id        Int       @id @default(autoincrement())
//   userId    Int
//   channelId Int
//   role      UserRole
//   banned    Boolean   @default(false)
//   unmuteAt  DateTime?
//   user      User      @relation(fields: [userId], references: [id])
//   channel   Channel   @relation(fields: [channelId], references: [id])

//   sendMessages ChannelMessage[]
//   readStatus ChannelMessageReadStatus[]

//   @@unique([userId, channelId])
// }

// enum ChannelVisibility {
//   PUBLIC
//   PROTECTED
//   PRIVATE
// }
