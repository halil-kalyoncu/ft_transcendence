--------------------
FRIENDLIST (Sidebar)
--------------------

VARIABLES

friends[]: FriendshipEntryI (custom)
unreadDirectMessages[]: UnreadMessagesI (custom)
// unreadGroupMessages[]: UnreadMessagesI (custom)
friendRequests[]: Friendship
// gameInvitations[]: Match

ON MOUNT

friends[] -> GET /api/friendships/get-accepted-friends
unreadDirectMessages[] -> GET /api/directMessages/allUnreadByUserId
// unreadGroupMessages[]
friendRequests[] -> GET /api/friendships/get-friend-requests
// gameInvitations[]

LISTENING ON EVENTS

friendlist: no payload
- update the friendlist with the api call (GET /api/friendships/get-accepted-friends)

newDirectMessage: DirectMessage
- update unreadDirectMessages with api call (GET /api/directMessages/allUnreadByUserId)

// newGroupMessage: GroupMessage
// - update unreadGroupMessages with api call ()

friendRequest: no payload
- update friendRequests with api call (GET /api/friendships/get-friend-requests)

// gameInvitation: no payload
// - update gameInvitations with api call ()

---------------------
DIRECT CHAT (Sidebar)
---------------------

VARIABLES

messages[]: DirectMessage

ON MOUNT

messages[] -> POST /api/directMessages/markAsRead (or GET /api/directMessages/getDirectMessages)
    - if you want to signalize new messages call GET /api/directMessages/getDirectMessages
    - but don't forget to call afterwards POST /api/directMessages/markAsRead
        - this call also returns the whole conversation buts sets the read flag

LISTENING ON EVENTS

newDirectMessage: DirectMessage
- check if this message's sender or receiver belongs in this chat
    - if it doesn't belongs here do nothing
- update messages with api call
    - use POST /api/directMessages/markAsRead to get the whole conversation and set the flag to read
    - GET /api/directMessages gets the whole conversation as well but doesn't sets the flag to read
        - idea behind this is that you could signalize that messages are new
        - use this until the user interacts with the chat for the first time and then use the other api call to get the conversation

SENDING EVENTS
- parameter CreateDirectMessageDto
    - at the end this events sends out newDirectMessage to the two clients

API calls

GET /api/directMessages

POST /api/directMessages/markAsRead

---------------------
CHANNELLIST (Sidebar)
---------------------

VARIABLES

friends[]: FriendshipEntryI (custom)
unreadDirectMessages[]: (custom)
unreadGroupMessages[]: (custom)
friendRequests[]: Friendship
gameInvitations[]: Match

LISTENING ON EVENTS

friendlist: ?
- update the friendlist with the api call (GET /api/friendships)

newDirectMessage: DirectMessage
- update unreadDirectMessages with api call ()

newGroupMessage: GroupMessage
- update unreadGroupMessages with api call ()

friendRequest: ?
- update friendRequests with api call ()

gameInvitation: ?
- update gameInvitations with api call ()

API calls

GET /api/friendships

GET /api/directMessages

GET /api/groupMessages

GET /api/friendship

GET /api/match/

----------------------
CHANNEL CHAT (Sidebar)
----------------------

VARIABLES

messages[]: GroupMessage

LISTENING ON EVENTS

newGroupMessage: GroupMessage
- check if this message's 
    - if it doesn't belong here do nothing
- update messages with api call
    - use POST /api/channelMessages/
    - GET /api/channelMessages gets the whole conversation as well but doesn't sets the flag to read
        - similar to direct chat

API CALLS

GET /api/channelMessages

POST /api/channelMessages/markAsRead

----------------------------------
CUSTOM TYPES (not in the database)
----------------------------------

enum FriendshipStatus
{
    ONLINE,
    OFFLINE,
    INGAME
}

interface FriendshipEntryI
{
    id: number,
    user: UserI,
    status: FriendshipStatus
}

----------------------------------

interface UnreadMessagesI {
  senderId: number,
  amountUnread: number
}

----------------------------------

interface CreateDirectMessageDto {
  senderId: number,
  receiverId: number,
  message: string,
}
